Project4_Omada_2789_1315_2702:

1. Alexandros Leventis, AEM: 2702, e-mail: lalexandros@uth.gr
2. Kwnstantinos Zouroufidis, AEM: 1315, e-mail: zouroufi@uth.gr
3. Lantzos Stergios, AEM: 2789, e-mail: lstergios@uth.gr



Σκοπός της εργασίας, ήταν η υλοποίηση ενός File System που χρησιμοποιεί την μέθοδο FUSE(= Filesystem in Userspace).
Οι παραδοχές που ακολουθήσαμε:

1. το μέγεθος αρχείων είναι πολλαπλάσιο των 4 KB (#define BASE 4096).
2. Οι λειτουργίες στις οποίες δουλέψαμε: ανάγνωση, αντιγραφή ,εγγραφή, δημιουργία και διαγραφή.
3. Αν δύο Blocks έχουν το ίδιο hash, τα θεωρούμε ίδια μέσω της συνάρτησης compareHash. Δηλαδή, αγνοήθηκε το hash collision.
4. Δεν ασχοληθήκαμε με thread safety , αμοιβαίο αποκλισμό / κρίσιμο τμήμα.
5. Υποθέσαμε πως το σύστημα αρχείων δεν θα αποτελείται από περισσότερα από 10 αρχεία, το καθένα μικρότερο από 64 ΚΒ.
6. Το filesystem θεωρήθηκε Volatile (αν γίνει unmount, και έπειτα mount, το Block υπάρχει στο .Storage, αλλά όχι μέσα
   στο hashFile.


Πειραματική αξιολόγηση:
Το κάθε Block αποθηκεύεται με όνομα "BLOCKxxx", όπου xxx είναι το ID του εκάστοτε Block.
Το format από το hash, είναι το ID, η τιμή του hash και τέλος πόσα αρχεία έχουν το ίδιο hash.
Αρχικά, κάναμε .configure.
Επειδή χρησιμοποιούμε την βιβλιοθήκη openSSL, για την χρήση της συνάρτησης SHA1, αντικαθιστούμε το Makefile 
στον φάκελο /src, με το ακόλουθο:


all:
	gcc -g -Wall bbfs.c log.c \
		`pkg-config fuse --cflags --libs` \
		`pkg-config libssl --cflags --libs` -o bbfs -lssl -lcrypto

clean:
		rm -rf ./bbfs

Στην συνέχεια, κάνουμε make, και mount το file system στον φάκελο 
example με την εντολή:  ../src/bbfs rootdir mountdir

Με την χρήση του nano, ελέγχουμε την λειτουργικότητα της δημιουργίας και εγγραφής νέων αρχείων, φτιάχνοντας στον 
φάκελο /mountdir δύο test αρχεία, με παραπλήσιο περιεχόμενο. Βλέπουμε πως το πρόγραμμα εντοπίζει τα κοινά Blocks 
ελέγχοντας τα hashes, με αποτέλεσμα να χρησιμοποιούνται λιγότερα Blocks για την αποθήκευση στον δίσκο. Παράλληλα ανανεώνεται
το hashFile, και ο δείκτης που δίνει πόσα αρχεία χρησιμοποιούν το ίδιο Block, αυξάνεται. Εάν διαγράψουμε τα αρχεία,
διαγράφονται και τα Blocks από τον δίσκο, και ο δείκτης μειώνεται αντίστοιχα. Ωστόσο, η εγγραφή του hash δεν διαγράφεται.


Για την εγγραφή, καλείται η bb_write(), και μέσα από αυτήν καλείται η overwriteBlocks, για να βρεθούν τα 
εκάστοτε Blocks που θα αντικατασταθούν. Έπειτα, η removeBlocks() για να αφαιρεθούν, και τέλος η 
bufToBlocks(), προκειμένου να γίνει η μετατροπή της εισόδου σε Blocks των 4 KB.
Μέσω της bufToBlocks(), καλείται η hashBlock(), η οποία δημιουργεί το hash για το Block, και έπειτα μέσω της 
compareHash(), κοιτάει αν υπάρχει το συγκεκριμένο hash μέσα στο hashFile. Αν δεν υπάρχει, δημιουργείται καινούργιο
Block με το συγκεκριμένο hash.


Για την ανάγνωση, καλείται η bb_read(), η οποία καλεί με την σειρά της την readFile(), ώστε να πάρουμε τα δεδομένα προς 
ανάγνωση. 
Έπειτα, αν επιστραφούν δεδομένα προς ανάγνωση από την readFile(), δημιουργείται ένα temp file
στο .Storage, το οποίο είναι κρυφό και περιέχει τα Blocks και το hashFile, και τα δεδομένα διαβάζονται από αυτό. 

(Η ανάγνωση ωστόσο, άρα και η αντιγραφή, δεν λειτουργούν: "transport end point is not connected").


Για την διαγραφή, καλείται η bb_unlink(), και η overwriteBlocks(), ώστε να βρει εκείνα τα Blocks που πρέπει να διαγραφούν. 
Στην συνέχεια, καλείται η removeBlocks(), για να τα διαγράψει.






